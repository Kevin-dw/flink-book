# 通过制作一个迷你flink来学习flink源码

## 缘起

在尚硅谷教授了一年多flink框架以后，我们决定写一本有关flink实践的书籍。将我们在讲课过程中碰到的难点以及碰撞出的火花沉淀下来，供业界参考，方便大家快速上手flink，以及能够实现一些复杂的需求和编写出高性能的flink流处理程序。

在授课以及研发课程的过程中，其实我们很少去深入研究源码，而是着重于熟练掌握flink提供的api，以及如何在应用程序层面写出高性能的flink程序。不去深入研究源码的原因有以下几点：

1. 盲目的去阅读源码可以说是学习编程最低效的一种方式。flink的源码非常庞大，有一百多万行Java代码以及几十万行Scala代码。不带任何目的的去读，非常容易迷失在源码里。想要去理解一个框架的原理，最好的方式是自己去实现一个，也就是广为人知的“造轮子”。比如想学习操作系统，就自己实现一个小的内核；想学习编译原理，就自己实现一个小的编译器；想学习web框，就自己实现一个小的web框架；想研究编辑器，可以自己动手实现一个简单的文本编辑器；等等（以上这些轮子，在下都造过，有些还造过不止一个）。

2. 学习编程最重要的方法依然是：不断的去写代码。而不是看代码。碰到问题，第一时间应该是去查看官方文档，使用搜索引擎搜索，以及去StackOverflow这样的网站去提问，如果碰到实在解决不了的问题，才去阅读源码，而这个时候，也必然对flink这个框架的使用已经非常熟练了，阅读源码也就有的放矢了。Torvalds Linus所说的“read the fucking source code”说的也就是这种情况。

3. flink源码很庞大，迭代了很多年，贡献人数接近1000，重构过很多次。所以源码里面使用了很多编程中比较高级的技术，例如：
  * 无处不在的依赖注入，这样的好处是解耦，但不好的地方就是阅读起来很困难，因为各种类的实现非常分散。当然解耦是大型项目必须要做的事情。
  * 大量使用了设计模式：工厂模式，观察者模式，还有例如访问者模式这样很少用到的设计模式（如果没有使用Java写过编译器或者解释器，基本不可能对访问者模式有比较深刻的理解，因为访问者模式最常用的场景就是遍历抽象语法树）。
  * 大量使用了一些Java的高级特性，例如Java的异步编程：Future特性；Java用来实现线程池的Executor接口；以及海量的匿名函数等等。
  * 底层通信大量使用了Scala编写的Akka以及Java的Netty。所以涉及到了Scala和Java的混合编程，这也是一个挑战。
